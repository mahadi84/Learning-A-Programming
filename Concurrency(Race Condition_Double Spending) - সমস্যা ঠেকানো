



### Concurrency সমস্যাটি কী ? 

-Race condition/Double Spending
যখন দুইজন (বা তার বেশি) প্রতিযোগী একই রিসোর্স (যেমন: ডেটাবেসের একটি রো) 
একই সময়ে অ্যাক্সেস বা পরিবর্তন করার চেষ্টা করে 
এবং তাদের মধ্যে কে আগে পৌঁছাবে তার ওপর ভিত্তি করে সিস্টেমের ফলাফল বদলে যায়, 
তখন তাকে Race Condition বলে।

The Scenario:
ধরুন, আপনার অ্যাকাউন্টে ৫,০০০ টাকা আছে।
১. একই সময়ে (At 10:00:01 AM): আপনি নিজে ৫০০ টাকা খরচ করছেন, আবার আপনার বন্ধু আপনাকে ২,০০০ টাকা পাঠাচ্ছে।
২. সিস্টেম প্রসেস: দুটি রিকোয়েস্টই ডাটাবেস থেকে দেখলো আপনার ব্যালেন্স ৫,০০০ টাকা।
৩. ফলাফল:  আপনার খরচ করা সার্ভিস হিসাব করবে: : 5000−500=4500 টাকা। * বন্ধুর পাঠানো সার্ভিস হিসাব করবে: 5000+2000=7000 টাকা।

৪. বিপদ: 
যে সার্ভিসটি সবার শেষে সেভ (Save) হবে, সেটি আগের ব্যালেন্সকে মুছে দেবে। 
যদি আপনার বন্ধুর ট্রানজ্যাকশন শেষে সেভ হয়, 
তবে আপনার ৫০০ টাকা খরচের কোনো রেকর্ডই ব্যালেন্সে থাকবে না!



### সফটওয়্যার ইঞ্জিনিয়ার হিসেবে আপনি এটি কীভাবে ঠেকাবেন?

ব্যাংকিং অ্যাপে যখন কনফ্লিক্ট হয়, তখন সাধারণত নিচের ৩টি পদ্ধতির যেকোনো একটি ফলো করা হয়:

1. Client Wins: ইউজারের পাঠানো ডেটাই Force করে Save করা (ব্যাংকিংয়ে এটি করা হয় না, কারণ এতে টাকা ভুল হতে পারে)।
2. Database Wins: ডাটাবেসে যা আছে তাই থাকবে, ইউজারের রিকোয়েস্ট Cancel হবে।
3. Retry (সেরা উপায়): সিস্টেম অটোমেটিক আবার নতুন ব্যালেন্স রিড করবে এবং পুনরায় হিসাব করে সেভ করার চেষ্টা করবে (যতক্ষণ না ভার্সন মিলে যাচ্ছে)।
                     -সিস্টেম যখন দেখবে ভার্সন মেলেনি (AAA এর বদলে BBB হয়ে গেছে), সে হাল ছেড়ে না দিয়ে অটোমেটিক ডাটাবেস থেকে নতুন ডেটা (BBB) রিড করবে এবং আবার হিসাব করে সেভ করার চেষ্টা করবে।
                        Ex: while (!saved && retryCount < 3) // সর্বোচ্চ ৩ বার চেষ্টা করবে
*** যদি অটোমেটিক রিট্রাই করা সম্ভব না হয় (যেমন অনেক বেশি ডেটা পরিবর্তন হয়ে গেছে), তবে সিস্টেম ইউজারকে একটি মেসেজ দেবে।
                       > মেসেজ: "আপনার ব্যালেন্স এর মধ্যে অন্য কোনো সোর্স থেকে আপডেট হয়েছে। দয়া করে পেজটি রিফ্রেশ করে আবার চেষ্টা করুন।"
                       > কেন এটি করা হয়? যাতে ইউজার নিশ্চিত হতে পারে সে বর্তমান ব্যালেন্স জেনেই টাকা পাঠাচ্ছে।


   


সফটওয়্যার ইঞ্জিনিয়ার হিসেবে আপনি এটি কীভাবে ঠেকাবেন?

আমরা আমাদের ব্যাংকিং প্রজেক্টে যে RowVersion ব্যবহার করেছি, 
সেটি এই Race Condition ঠেকানোর একটি অন্যতম উপায়। 
এর বাইরেও কিছু পদ্ধতি আছে:

১. Optimistic Locking: (আমরা যা ব্যবহার করেছি) RowVersion দিয়ে চেক করা যে ডেটা রিড করার পর থেকে সেভ করার মাঝখানে কেউ তা বদলে দিয়েছে কি না। 
                        ১.১. আপনি যখন ডাটা রিড করেন, তখন সিস্টেম `RowVersion` টিও সাথে নিয়ে আসে (ধরুন এর মান `AAA`)।
                        ১.২. আপনি যখন ব্যালেন্স আপডেট করে ডাটাবেসে পাঠাবেন, ডাটাবেস চেক করবে: "এখনো কি এই রো-এর ভার্সন `AAA` আছে?"
                        ১.৩. যদি এর মধ্যে আপনার বন্ধু ব্যালেন্স আপডেট করে দেয়, তবে ডাটাবেসে ভার্সনটি বদলে `BBB` হয়ে যাবে।
                        ১.৪. এখন আপনার সার্ভিস যখন `AAA` ভার্সন নিয়ে আপডেট করতে যাবে, ডাটাবেস দেখবে ভার্সন মেলেনি। 
                             সে সাথে সাথে আপডেটটি Reject করে দেবে এবং একটি Concurrency Exception থ্রো করবে।
২. Pessimistic Locking: যখন একজন ডাটা এডিট করবে, তখন অন্য সবার জন্য ওই রো-টি "Lock" করে দেওয়া হবে। কাজ শেষ না হওয়া পর্যন্ত কেউ রিড বা রাইট করতে পারবে না। 
৩. Atomic Operations: এমন ভাবে কোড লেখা যাতে পুরো অপারেশনটি একটি একক ইউনিট হিসেবে কাজ করে (Transaction)।






.
